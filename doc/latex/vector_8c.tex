\hypertarget{vector_8c}{}\section{ds/vector.c File Reference}
\label{vector_8c}\index{ds/vector.\+c@{ds/vector.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include \char`\"{}vector.\+h\char`\"{}}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$ \hyperlink{vector_8c_aefd0995c21f04f7e879f0263f600b41c}{ds\+\_\+vector\+\_\+create} ()
\item 
struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$ \hyperlink{vector_8c_ac6ed19262b452ee335826aba817c63d1}{ds\+\_\+vector\+\_\+create\+\_\+capacity} (int32\+\_\+t capacity)
\item 
void \hyperlink{vector_8c_ade407775904bab6cde24052138056da9}{ds\+\_\+vector\+\_\+free} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec)
\item 
void \hyperlink{vector_8c_abdbcaae263961908730da00e39bd1c5c}{ds\+\_\+vector\+\_\+free\+\_\+no\+\_\+data} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec)
\item 
struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$ \hyperlink{vector_8c_a5fd466f5ab26a4f5f9b0075381da561b}{ds\+\_\+vector\+\_\+copy} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec)
\item 
void \hyperlink{vector_8c_a517e8b11e1da592210781870b1865c5f}{ds\+\_\+vector\+\_\+append} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec, void $\ast$data)
\item 
void \hyperlink{vector_8c_a36df89eeb7abd1989eb7a84f1b1afcab}{ds\+\_\+vector\+\_\+insert} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec, void $\ast$data, int32\+\_\+t index)
\item 
void \hyperlink{vector_8c_a2085d11c3e93683b639f8204fa8d9730}{ds\+\_\+vector\+\_\+remove} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec, int32\+\_\+t index)
\item 
void $\ast$ \hyperlink{vector_8c_ab074e786ccba3d2ee940a468527773f3}{ds\+\_\+vector\+\_\+get} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec, int32\+\_\+t index)
\item 
void \hyperlink{vector_8c_ae92f0df5f819c841a2f75d6d5d611f7e}{ds\+\_\+vector\+\_\+set} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec, void $\ast$data, int32\+\_\+t index)
\item 
void \hyperlink{vector_8c_a2bbf251632f74acc28a43e84e2e51a0f}{ds\+\_\+vector\+\_\+swap} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec, int32\+\_\+t i, int32\+\_\+t j)
\item 
void \hyperlink{vector_8c_a0343ab9b92e8e4e6ff836bbfebebe077}{ds\+\_\+vector\+\_\+map} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec, void(func)(void $\ast$))
\item 
int32\+\_\+t \hyperlink{vector_8c_a1d7f514b9cac5794cd0ee65401c31477}{ds\+\_\+vector\+\_\+find} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec, void $\ast$needle, int32\+\_\+t(compare)(void $\ast$, void $\ast$))
\item 
void \hyperlink{vector_8c_a91228659d8014ef3e340df24c8fa535a}{ds\+\_\+vector\+\_\+sort} (struct \hyperlink{structDSVector}{D\+S\+Vector} $\ast$vec, int32\+\_\+t(compare)(void $\ast$, void $\ast$))
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+append@{ds\+\_\+vector\+\_\+append}}
\index{ds\+\_\+vector\+\_\+append@{ds\+\_\+vector\+\_\+append}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+append(struct D\+S\+Vector $\ast$vec, void $\ast$data)}{ds_vector_append(struct DSVector *vec, void *data)}}]{\setlength{\rightskip}{0pt plus 5cm}void ds\+\_\+vector\+\_\+append (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec, }
\item[{void $\ast$}]{data}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_a517e8b11e1da592210781870b1865c5f}{}\label{vector_8c_a517e8b11e1da592210781870b1865c5f}
Adds an element to the end of a vector. Runs in constant time. 

Definition at line 75 of file vector.\+c.



References D\+S\+Vector\+::data, and D\+S\+Vector\+::size.



Referenced by ds\+\_\+hashmap\+\_\+put\+\_\+int(), and ds\+\_\+vector\+\_\+copy().

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+copy@{ds\+\_\+vector\+\_\+copy}}
\index{ds\+\_\+vector\+\_\+copy@{ds\+\_\+vector\+\_\+copy}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+copy(struct D\+S\+Vector $\ast$vec)}{ds_vector_copy(struct DSVector *vec)}}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf D\+S\+Vector}$\ast$ ds\+\_\+vector\+\_\+copy (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_a5fd466f5ab26a4f5f9b0075381da561b}{}\label{vector_8c_a5fd466f5ab26a4f5f9b0075381da561b}
Copies a vector, but not the data. Make sure you free it! 

Definition at line 62 of file vector.\+c.



References D\+S\+Vector\+::capacity, D\+S\+Vector\+::data, ds\+\_\+vector\+\_\+append(), ds\+\_\+vector\+\_\+create\+\_\+capacity(), and D\+S\+Vector\+::size.

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+create@{ds\+\_\+vector\+\_\+create}}
\index{ds\+\_\+vector\+\_\+create@{ds\+\_\+vector\+\_\+create}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+create()}{ds_vector_create()}}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf D\+S\+Vector}$\ast$ ds\+\_\+vector\+\_\+create (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_aefd0995c21f04f7e879f0263f600b41c}{}\label{vector_8c_aefd0995c21f04f7e879f0263f600b41c}
Creates a vector with D\+S\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+B\+A\+S\+E\+\_\+\+C\+A\+P\+A\+C\+I\+TY. ds\+\_\+vector\+\_\+free or ds\+\_\+vector\+\_\+free\+\_\+no\+\_\+data will need to be called when done with the vector to avoid memory leaks. 

Definition at line 21 of file vector.\+c.



References ds\+\_\+vector\+\_\+create\+\_\+capacity().



Referenced by ds\+\_\+hashmap\+\_\+create().

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+create\+\_\+capacity@{ds\+\_\+vector\+\_\+create\+\_\+capacity}}
\index{ds\+\_\+vector\+\_\+create\+\_\+capacity@{ds\+\_\+vector\+\_\+create\+\_\+capacity}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+create\+\_\+capacity(int32\+\_\+t capacity)}{ds_vector_create_capacity(int32_t capacity)}}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf D\+S\+Vector}$\ast$ ds\+\_\+vector\+\_\+create\+\_\+capacity (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t}]{capacity}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_ac6ed19262b452ee335826aba817c63d1}{}\label{vector_8c_ac6ed19262b452ee335826aba817c63d1}
Creates a vector with the given capacity. (N.\+B. This vector will still automatically increase in size if necessary.) 

Definition at line 27 of file vector.\+c.



References D\+S\+Vector\+::capacity, D\+S\+Vector\+::data, and D\+S\+Vector\+::size.



Referenced by ds\+\_\+vector\+\_\+copy(), and ds\+\_\+vector\+\_\+create().

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+find@{ds\+\_\+vector\+\_\+find}}
\index{ds\+\_\+vector\+\_\+find@{ds\+\_\+vector\+\_\+find}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+find(struct D\+S\+Vector $\ast$vec, void $\ast$needle, int32\+\_\+t(compare)(void $\ast$, void $\ast$))}{ds_vector_find(struct DSVector *vec, void *needle, int32_t(compare)(void *, void *))}}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t ds\+\_\+vector\+\_\+find (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec, }
\item[{void $\ast$}]{needle, }
\item[{int32\+\_\+t(compare)(void $\ast$, void $\ast$)}]{}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_a1d7f514b9cac5794cd0ee65401c31477}{}\label{vector_8c_a1d7f514b9cac5794cd0ee65401c31477}
Higher-\/order function to find the first element in the vector such that compare(needle, element) == 0. Where compare is defined as\+: compare(a, b) $<$ 0 when a $<$ b compare(a, b) = 0 when a = b compare(a, b) $>$ 0 when a $>$ b

Returns an unsigned -\/1 if needle is not found. 

Definition at line 154 of file vector.\+c.



References D\+S\+Vector\+::data, and D\+S\+Vector\+::size.

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+free@{ds\+\_\+vector\+\_\+free}}
\index{ds\+\_\+vector\+\_\+free@{ds\+\_\+vector\+\_\+free}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+free(struct D\+S\+Vector $\ast$vec)}{ds_vector_free(struct DSVector *vec)}}]{\setlength{\rightskip}{0pt plus 5cm}void ds\+\_\+vector\+\_\+free (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_ade407775904bab6cde24052138056da9}{}\label{vector_8c_ade407775904bab6cde24052138056da9}
Free\textquotesingle{}s a vector A\+ND its data. 

Definition at line 43 of file vector.\+c.



References D\+S\+Vector\+::data, and D\+S\+Vector\+::size.

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+free\+\_\+no\+\_\+data@{ds\+\_\+vector\+\_\+free\+\_\+no\+\_\+data}}
\index{ds\+\_\+vector\+\_\+free\+\_\+no\+\_\+data@{ds\+\_\+vector\+\_\+free\+\_\+no\+\_\+data}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+free\+\_\+no\+\_\+data(struct D\+S\+Vector $\ast$vec)}{ds_vector_free_no_data(struct DSVector *vec)}}]{\setlength{\rightskip}{0pt plus 5cm}void ds\+\_\+vector\+\_\+free\+\_\+no\+\_\+data (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_abdbcaae263961908730da00e39bd1c5c}{}\label{vector_8c_abdbcaae263961908730da00e39bd1c5c}
Free\textquotesingle{}s just the vector\textquotesingle{}s representation. Data is N\+OT freed. 

Definition at line 55 of file vector.\+c.



References D\+S\+Vector\+::data.



Referenced by ds\+\_\+hashmap\+\_\+free().

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+get@{ds\+\_\+vector\+\_\+get}}
\index{ds\+\_\+vector\+\_\+get@{ds\+\_\+vector\+\_\+get}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+get(struct D\+S\+Vector $\ast$vec, int32\+\_\+t index)}{ds_vector_get(struct DSVector *vec, int32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ ds\+\_\+vector\+\_\+get (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec, }
\item[{int32\+\_\+t}]{index}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_ab074e786ccba3d2ee940a468527773f3}{}\label{vector_8c_ab074e786ccba3d2ee940a468527773f3}
Gets an element at index i from a vector. 

Definition at line 114 of file vector.\+c.



References D\+S\+Vector\+::data, and D\+S\+Vector\+::size.



Referenced by ds\+\_\+hashmap\+\_\+foreach\+\_\+value(), ds\+\_\+hashmap\+\_\+foreach\+\_\+value\+Action(), ds\+\_\+hashmap\+\_\+print\+\_\+keys(), ds\+\_\+hashmap\+\_\+print\+\_\+keyvals(), and ds\+\_\+hashmap\+\_\+remove\+\_\+int().

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+insert@{ds\+\_\+vector\+\_\+insert}}
\index{ds\+\_\+vector\+\_\+insert@{ds\+\_\+vector\+\_\+insert}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+insert(struct D\+S\+Vector $\ast$vec, void $\ast$data, int32\+\_\+t index)}{ds_vector_insert(struct DSVector *vec, void *data, int32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ds\+\_\+vector\+\_\+insert (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec, }
\item[{void $\ast$}]{data, }
\item[{int32\+\_\+t}]{index}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_a36df89eeb7abd1989eb7a84f1b1afcab}{}\label{vector_8c_a36df89eeb7abd1989eb7a84f1b1afcab}
Places an element at index i, and shifts the rest of the vector to the right by one. If index == size of vector, then the element will be appended to the end of the vector. 

Definition at line 82 of file vector.\+c.



References D\+S\+Vector\+::data, and D\+S\+Vector\+::size.

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+map@{ds\+\_\+vector\+\_\+map}}
\index{ds\+\_\+vector\+\_\+map@{ds\+\_\+vector\+\_\+map}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+map(struct D\+S\+Vector $\ast$vec, void(func)(void $\ast$))}{ds_vector_map(struct DSVector *vec, void(func)(void *))}}]{\setlength{\rightskip}{0pt plus 5cm}void ds\+\_\+vector\+\_\+map (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec, }
\item[{void(func)(void $\ast$)}]{}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_a0343ab9b92e8e4e6ff836bbfebebe077}{}\label{vector_8c_a0343ab9b92e8e4e6ff836bbfebebe077}
Higher-\/order function to map func over every element in vector. 

Definition at line 145 of file vector.\+c.



References D\+S\+Vector\+::data, and D\+S\+Vector\+::size.

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+remove@{ds\+\_\+vector\+\_\+remove}}
\index{ds\+\_\+vector\+\_\+remove@{ds\+\_\+vector\+\_\+remove}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+remove(struct D\+S\+Vector $\ast$vec, int32\+\_\+t index)}{ds_vector_remove(struct DSVector *vec, int32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ds\+\_\+vector\+\_\+remove (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec, }
\item[{int32\+\_\+t}]{index}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_a2085d11c3e93683b639f8204fa8d9730}{}\label{vector_8c_a2085d11c3e93683b639f8204fa8d9730}
Removes an element from the vector at some index. Also shifts everything to right of index to the left. Does {\itshape N\+OT} free the data. 

Definition at line 101 of file vector.\+c.



References D\+S\+Vector\+::data, and D\+S\+Vector\+::size.



Referenced by ds\+\_\+hashmap\+\_\+remove\+\_\+int().

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+set@{ds\+\_\+vector\+\_\+set}}
\index{ds\+\_\+vector\+\_\+set@{ds\+\_\+vector\+\_\+set}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+set(struct D\+S\+Vector $\ast$vec, void $\ast$data, int32\+\_\+t index)}{ds_vector_set(struct DSVector *vec, void *data, int32_t index)}}]{\setlength{\rightskip}{0pt plus 5cm}void ds\+\_\+vector\+\_\+set (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec, }
\item[{void $\ast$}]{data, }
\item[{int32\+\_\+t}]{index}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_ae92f0df5f819c841a2f75d6d5d611f7e}{}\label{vector_8c_ae92f0df5f819c841a2f75d6d5d611f7e}
Sets an elements at index to data. No data is freed. 

Definition at line 123 of file vector.\+c.



References D\+S\+Vector\+::data, and D\+S\+Vector\+::size.

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+sort@{ds\+\_\+vector\+\_\+sort}}
\index{ds\+\_\+vector\+\_\+sort@{ds\+\_\+vector\+\_\+sort}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+sort(struct D\+S\+Vector $\ast$vec, int32\+\_\+t(compare)(void $\ast$, void $\ast$))}{ds_vector_sort(struct DSVector *vec, int32_t(compare)(void *, void *))}}]{\setlength{\rightskip}{0pt plus 5cm}void ds\+\_\+vector\+\_\+sort (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec, }
\item[{int32\+\_\+t(compare)(void $\ast$, void $\ast$)}]{}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_a91228659d8014ef3e340df24c8fa535a}{}\label{vector_8c_a91228659d8014ef3e340df24c8fa535a}
I\textquotesingle{}ve implemented my own Quicksort (based on the Wikipedia entry on Quicksort) because I didn\textquotesingle{}t like how the standard library\textquotesingle{}s version of qsort forces you to define the comparison function. (Namely, that the arguments are void$\ast$$\ast$ instead of void$\ast$.) 

Definition at line 173 of file vector.\+c.



References D\+S\+Vector\+::capacity, D\+S\+Vector\+::data, and D\+S\+Vector\+::size.



Referenced by ds\+\_\+hashmap\+\_\+sort\+\_\+by().

\index{vector.\+c@{vector.\+c}!ds\+\_\+vector\+\_\+swap@{ds\+\_\+vector\+\_\+swap}}
\index{ds\+\_\+vector\+\_\+swap@{ds\+\_\+vector\+\_\+swap}!vector.\+c@{vector.\+c}}
\subsubsection[{\texorpdfstring{ds\+\_\+vector\+\_\+swap(struct D\+S\+Vector $\ast$vec, int32\+\_\+t i, int32\+\_\+t j)}{ds_vector_swap(struct DSVector *vec, int32_t i, int32_t j)}}]{\setlength{\rightskip}{0pt plus 5cm}void ds\+\_\+vector\+\_\+swap (
\begin{DoxyParamCaption}
\item[{struct {\bf D\+S\+Vector} $\ast$}]{vec, }
\item[{int32\+\_\+t}]{i, }
\item[{int32\+\_\+t}]{j}
\end{DoxyParamCaption}
)}\hypertarget{vector_8c_a2bbf251632f74acc28a43e84e2e51a0f}{}\label{vector_8c_a2bbf251632f74acc28a43e84e2e51a0f}
Swaps the data from vector element i to vector element j. 

Definition at line 132 of file vector.\+c.



References D\+S\+Vector\+::data, and D\+S\+Vector\+::size.

